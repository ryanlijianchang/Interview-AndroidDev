### 一、Android有哪些经典的内存泄露场景，如何能提早发现代码中有内存泄露的隐患？ ###

#### 经典场景 ####

**1. Activity中的Handler长期持有activity引用导致activity泄漏。**

    (1). 在Activity内new一个Handler时，该handler实例会对Activity持有一个隐式的引用。
    (2). 而当消息队列中的消息被looper拿到然后给handler处理，又会对外部类handler持有隐式引用。
    (3). 当Activity被finish掉后，消息队列未处理完，而handler持有对activity引用，因此即使activity被finish掉，也不会被gc掉。
**解决方法：**

    (1) 将内部类handler创建到外部类，handler仅持有activi ty的弱引用。
    (2) 将内部类handler设为静态，因为静态内部类不持有对外部类的引用。
    (3) 或者在activity的onDestory方法中干掉handler的所有callback和message，mHandler.removeCallbacksAndMessages(null);

**2. 非静态匿名内部类造成内存泄露**

    (1)当我们在Activity中直接new一个Thread，但当我们的Activity被finish时，Thread仍在运行，就造成了内存泄露

**解决方式：**

    (1)同样把Thread定义为静态的内部类，这样就不会持有外部类的引用。


**3. 单例+依赖注入**

    (1)当我们在单例类中(静态实体，生命周期和App一样，非常长)持有对Activity的对象引用，造成内存泄露

#### 提前发现 ####

**1.通过工具**

    (1)通过Android Studio的Monitor工具，打开Memory标签查看内存变化情况，通过dump java head采集数据，生成hprof文件
    (2)通过MAT工具，导入hprof文件，它会帮我们分析内存泄露的原因
    (3)通过LeakCanary插件，LeakCanary会在app运行时分析当前的内存快照，找到对象的引用链，并显示到页面上，好处是可以直接在手机上查看（如果检测到泄漏会发送到通知栏，点击通知栏就可以跳转到具体的泄漏分析页面。）

**2.通过代码**

    (1)debug版本可以起一个长期工作的线程LeakThread在后台专门做泄漏检测
    (2)向Application注册一个 页面生命周期 的监听：application.registerActivityLifecycleCallbacks
    (3)在监听类中对 onActivityDestoryed(Activity activity) 的事件回调做处理：
             如果一个Activity走到onDestroy，那么这个Activity对象就是需要被回收的目标。
             我们声明一个检测对象的弱引用ref = new WeakReference(activity)
    (4)在 LeakThread中我们每隔一段时间检测一下ref.get() 是否为空，为空说明activity已被释放。不为空可以手动触一次发gc；如果超过一段时间，比如50s，页面对象还未被清理，我们可以推断内存泄漏的发生。
    (5)当内存泄漏发生时，提示给开发者，并自动dump出.prof文件。